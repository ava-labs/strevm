name: Go

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}


env:
  EXECUTION_SPEC_TESTS_VERSION: v2.1.0
  EXECUTION_SPEC_TESTS_CHECKSUM: ca89c76851b0900bfcc3cbb9a26cbece1f3d7c64a3bed38723e914713290df6c
  EXECUTION_SPEC_TESTS_PATH: saexec/ethtests/spec-tests

permissions:
  contents: read

jobs:
  # If adding a new job, add it to the `needs` list of the `go` job as this is
  # what gates PRs.
  go:
    runs-on: ubuntu-latest
    needs: [go_test, go_generate, go_tidy, require_fuzz_corpus]
    # TODO(arr4n) investigate why setup-go wasn't properly caching fuzz corpora
    # and then reinstate a go_fuzz job that extends them.
    steps:
      - run: echo "Dependencies successful"

  # TODO(cey): we should only run -short tests in PRs and then run the full tests in main.
  go_test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Download and extract execution spec tests
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p "${EXECUTION_SPEC_TESTS_PATH}"
          # Download the archive
          curl -L -o /tmp/fixtures_develop.tar.gz https://github.com/ethereum/execution-spec-tests/releases/download/${EXECUTION_SPEC_TESTS_VERSION}/fixtures_develop.tar.gz
          # Verify checksum (replace EXPECTED_CHECKSUM with actual value)
          ACTUAL_CHECKSUM=$(sha256sum /tmp/fixtures_develop.tar.gz | cut -d' ' -f1)
          if [ "$ACTUAL_CHECKSUM" != "$EXECUTION_SPEC_TESTS_CHECKSUM" ]; then
            echo "Checksum mismatch! Expected: $EXPECTED_CHECKSUM, Got: $ACTUAL_CHECKSUM"
            exit 1
          fi
          # Extract if verification passes
          tar -xz -f /tmp/fixtures_develop.tar.gz -C "${EXECUTION_SPEC_TESTS_PATH}"
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: "go.mod"
      - run: go test -short ./...

  go_generate:
    env:
      EXCLUDE_REGEX: "ava-labs/libevm/(accounts/usbwallet/trezor)$"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: "go.mod"

      - name: Run `go generate`
        run: go list ./... | grep -Pv "${EXCLUDE_REGEX}" | xargs go generate;

      - name: git diff
        run: git diff --exit-code

  go_tidy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: "go.mod"
      - run: go mod tidy
      - run: git diff --exit-code

  find_fuzz_targets:
    runs-on: ubuntu-latest
    outputs:
      targets: ${{ steps.find.outputs.targets }}
    steps:
      - uses: actions/checkout@v4
      - id: find
        run: |
          echo "targets=$(grep --recursive --include '**_test.go' -oP "^func \KFuzz[^(]+" | xargs jq -c -n '$ARGS.positional' --args)" >> $GITHUB_OUTPUT

  require_fuzz_corpus:
    needs: [find_fuzz_targets]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: ${{fromJSON(needs.find_fuzz_targets.outputs.targets)}}
    env:
      # The actual corpus size is dependent on the test in question and how many
      # "interesting" cases can be found. This is an arbitrary lower bound,
      # chosen as approximately half the size of the very basic
      # `FuzzEffectiveGasTip`.
      MIN_CORPUS_SIZE: 20
    steps:
      - run: |
          echo "${{ matrix.target }}" | awk -F: '{print $1}' | xargs dirname | xargs -i echo "PACKAGE={}" >> "$GITHUB_ENV"
      - run: |
          echo "${{ matrix.target }}" | awk -F: '{print $2}' | xargs -i echo "FUNCTION={}" >> "$GITHUB_ENV"
      - run: |
          echo "CORPUS_DIR=./${PACKAGE}/testdata/fuzz/${FUNCTION}" >> "$GITHUB_ENV"
      - uses: actions/checkout@v4
      - name: Require existing corpus of at least ${MIN_CORPUS_SIZE}
        run: | # Raw `go test` will be meaningful, and `-fuzz` won't start from nowhere
          [ -d "${CORPUS_DIR}" ] && [ $(ls "${CORPUS_DIR}" | wc -l) -gt ${MIN_CORPUS_SIZE} ]
